#!/usr/bin/env python
from xpipeline.setuputils import log

from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten
from keras.layers import MaxPooling2D, Conv2D
from keras.metrics import categorical_accuracy
from keras.regularizers import l2
from keras.optimizers import RMSprop
from keras.layers import GaussianNoise

import argparse
import os
import tables
import numpy
import pandas

def parse_commandline():
    """Parse the options given on the command-line.
    """
    parser = argparse.ArgumentParser(description="")
    parser.add_argument("--batch-size", type=int, default=30,
                        help="defines the batch size, 30 is a reasonable size")
    parser.add_argument("--nb-epoch", type=int, default=20,
                        help="defines the number of iterations, "
                        "0.1 is reasonable. You can set it to 100 or below, "
                        "if you have time concern for training.")
    parser.add_argument("--randomseed", type=int, default=1986,
                        help="Set random seed")
    args = parser.parse_args()

    return args

args = parse_commandline()
numpy.random.seed(args.randomseed)

background_trainingset = numpy.load('background_trainingset.npy',)
background_validation = numpy.load('background_validation.npy',)

injection_trainingset = numpy.load('injection_trainingset.npy',)
injection_validation = numpy.load('injection_validation.npy',)

background_labels_training = numpy.zeros(background_trainingset.shape[0])
background_labels_validation = numpy.zeros(background_validation.shape[0])

injection_labels_training = numpy.ones(injection_trainingset.shape[0])
injection_labels_validation = numpy.ones(injection_validation.shape[0])

trainingset = numpy.concatenate([background_trainingset, injection_trainingset])
trainingset_labels = numpy.concatenate([background_labels_training, injection_labels_training])

validation = numpy.abs(numpy.concatenate([background_validation , injection_validation ]))
validation_labels = numpy.concatenate([background_labels_validation, injection_labels_validation])

reshuffle_training = numpy.arange(0, trainingset_labels.size,).astype(int)
reshuffle_validation = numpy.random.randint(0, validation_labels.size,size = int(validation_labels.size*0.5)).astype(int)
numpy.random.shuffle(reshuffle_training)

trainingset = numpy.abs(trainingset[reshuffle_training])
trainingset_labels = trainingset_labels[reshuffle_training]

testing_set = validation[~reshuffle_validation]
testing_set_labels = validation_labels[~reshuffle_validation]

validation = validation[reshuffle_validation]
validation_labels = validation_labels[reshuffle_validation]

del background_trainingset
del background_validation
del injection_trainingset
del injection_validation

input_shape = trainingset[0].shape

model = Sequential()
W_reg = 1e-4
model.add(Conv2D(16, (1, 7), strides=(1, 7), padding='valid',
          input_shape=input_shape,
          kernel_regularizer=l2(W_reg)))
model.add(Activation("tanh"))

model.add(Conv2D(32, (1, 1), strides=(1, 1), padding='valid', kernel_regularizer=l2(W_reg)))
model.add(Activation("tanh"))

model.add(Flatten())
model.add(Dense(128, kernel_regularizer=l2(W_reg)))
model.add(Activation('tanh'))

model.add(Dense(1, activation='sigmoid'))

print(model.summary())

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

model.fit(trainingset, trainingset_labels,
    batch_size=args.batch_size, epochs=args.nb_epoch, verbose=1,
    validation_data=(validation, validation_labels), callbacks=[],)

model.save('cnn.h5')
print(model.evaluate(validation, validation_labels, verbose=0))
print(model.evaluate(testing_set, testing_set_labels, verbose=0))
