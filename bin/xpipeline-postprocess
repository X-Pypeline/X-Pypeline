#!/usr/bin/env python
from xpipeline.core import XSparseTimeFrequencyMapDict, csc_XSparseTimeFrequencyMap
from xpipeline.cluster.cluster import XCluster
from csv import writer

import io
import argparse
import os
import tables
import numpy
import pandas

def parse_commandline():
    parser = argparse.ArgumentParser(description="This executable processes "
                                                 "a xpipeline-analysis "
                                                 "generated file of tfmaps.")
    # Define groups of flags to make the help output ore useful
    required_args = parser.add_argument_group('required named arguments')
    required_args.add_argument("-f", "--event-file", help=
                               """
                               trigger file
                               """,
                               required=True,)

    args = parser.parse_args()

    if os.path.isfile(args.event_file):
        raise parser.error('You have supplied a non-existent event-file.')

    return args

args = parse_commandline()

logger = log.Logger('XPIPELINE: Post-Processing {0}'.format(args.event_file))

# Read parameters
f = tables.open_file(args.event_file)
all_clusters = pandas.DataFrame()
for table in f.walk_nodes('/background', "Table"):
    channel_names = numpy.unique(table.cols.ifo).astype(str)
    for fft_length in set(table.cols.dx):
        for phi, theta in set(zip(table.cols.phi, table.cols.theta)):
            sparse_maps = [csc_XSparseTimeFrequencyMap.read(row)
                            for row in table.where("""(dx == {0}) & (map_type == \'excess_energy\') & (phi == {1}) & (theta == {2})""".format(fft_length, phi, theta,))]
            sparse_maps = XSparseTimeFrequencyMapDict({imap.name: imap for imap in sparse_maps})
            clusters = sparse_maps.abs().cluster()
        all_clusters = all_clusters.append(clusters) 
